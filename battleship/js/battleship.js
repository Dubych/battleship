var model = {//объект модели
	boardSize: 10,//размер сетки игрового поля
	numShips: 5,//кол-во кораблей в игре
	shipLength: 3,//длина каждого корабля (в клетках)
	shipsSunk: 0,//кол-во потопленных кораблей

	ships: [{ locations: [0, 0, 0], hits: ["", "", ""]},
					{ locations: [0, 0, 0], hits: ["", "", ""]},
					{ locations: [0, 0, 0], hits: ["", "", ""]},
					{ locations: [0, 0, 0], hits: ["", "", ""]},
					{ locations: [0, 0, 0], hits: ["", "", ""]}],

	//метод fire преобразует выстрел игрока в промах или попадание
	fire: function(guess) {//метод получает координаты выстрела
		for (var i = 0; i < this.numShips; i++) {//перебирается массив ships, последовательно проверяя каждый корабль
				var ship = this.ships[i];//получаем объект корабля, и необходимо проверить, совпадают коорд. выстрела, с коорд. одной из занимаемых им клеток  
				var index = ship.locations.indexOf(guess);//метод indexOf ищет в массиве указан. знач. и возвр. его индекс (или -1, если знач. отсутств. в массиве)
				
				if (ship.hits[index] === "hit") {
					view.displayMessage("Ух, в эту клетку вы уже стреляли!");
					return true;
				} else if (index >= 0) {//если получ. индекс больше либо равен нулю, значит указанная клетка присутств. в массиве locations и выстрел попал в цель
					ship.hits[index] = "hit";//ставим отметку в массиве hits по тому же индексу
					view.displayHit(guess);//оповещаем что в клетке guess следует вывести маркер попадания
					view.displayMessage("РАНИЛ!");//выводим сообщение "HIT!"
					
					if (this.isSunk(ship)) {//если корабль потоплен>>
						view.displayMessage("Корабль потоплен!");//сообщаем игроку что он потопил корабль
						this.shipsSunk++;//>>увеличиваем счетчик потопленных кораблей в свойстве shipsSunk модели
					}
					return true;//возвращ. true т.к. выстрел удачный
				}
		}
		view.displayMiss(guess);//оповещаем что в клетке guess следует вывести маркер промаха
		view.displayMessage("МИМО!");//выводим сообщение "You missed. :-("
		return false;//если после перебора всех кораблей попаданий не обнаруж., значит игрок промахнулся, метод возвращает false
	},

	//метод проверки, потоплен ли корабль
	isSunk: function(ship) {//метод isSunk получает объект корабля и возвр. true, если корабль потоплен, иначе false
		for (var i = 0; i < this.shipLength; i++) {//проверяем, помечены ли все клетки корабля маркером попадания
			if (ship.hits[i] !== "hit") {//если есть хотя бы одна клетка в которую еще не попал игрок, значит корабль не потоплен>>
				return false;//>>метод возвращает false
			}
		}
		return true;//если корабль потоплен, метод возвращает true
	},
	
	//generateShipLocations - основной метод, который создает в модели массив ships с кол-вом кораблей, определяемым свойством numShips модели
	generateShipLocations: function() {//методом generateShipLocations создаем корабли
		var locations;//объявляем переменную locations
		for (var i = 0; i < this.numShips; i++) {//для каждого корабля генерируется набор позиций, то есть занимаемых клеток
			do {//цикл do while
				locations = this.generateShip();//генерируем новый набор позиций>>
			} while (this.collision(locations));//>>и проверяем, перекрываются ли эти позиции с существующими кораблями на доске, если есть перекрытие, возврвщаемся к do, новые позиции генерируются, до тех пор, пока не будут найдены варианты без перекрытий
			this.ships[i].locations = locations;//полученные позиции без перекрытий сохраняются в свойстве locations объекта корабля в массиве model.ships
		}
	},

	//метод generateShip создает массив со случайными позициями корабля
	generateShip: function() {//метод generateShip не учитывает возможные перекрытия 
		var direction = Math.floor(Math.random() * 2);//при помощи Math.random генерируем число от 0 до 1 и умножаем результат на 2, чтобы получить число в диапазоне от 0 до 2(не включая 2), затем Math.floor преобразует результат в 0 или 1 случайным образом
		var row, col;

		if (direction === 1) {//если значение direction равно 1, создается горизонтальный корабль, 
			//этот код генерирует начальную позицию корабля на игровом поле
			row = Math.floor(Math.random() * this.boardSize);//горизонтальный корабль может распологаться в любой строке от 0 до 9
			col = Math.floor(Math.random() * (this.boardSize - this.shipLength));//однако при выборе первого столбца нужно оставить место для двух других, поэтому мы уменьшаем размер поля(10) на 3, чтобы начальный столбец всегда лежал в диапазоне от 0 до 7
		} else {//если значение не равно 1, то есть 0, создается вертикальный корабль
			row = Math.floor(Math.random() * (this.boardSize - this.shipLength));//вертикальный корабль должен начинаться в строке от 0 до 7, чтобы осталось место еще для двух клеток 
			col = Math.floor(Math.random() * this.boardSize);//вертикальный корабль может распологаться в любом солбце от 0 до 9
		}
		//создаем пустой массив
		var newShipLocations = [];//набор позиций(клеток) нового корабля начинается с пустого массива, в который последовательно добавляются элементы
		for (var i = 0; i < this.shipLength; i++) {//в цикле до количества позиций(клеток) в корабле
			if (direction === 1) {//как мы уже знаем, если сгенерировался горизонтальный корабль
				newShipLocations.push(row + "" + (col + i));//новая позиция заносится в массив newShipLocations, данные состоят из начальной, вычесленной выше строки и столбца + i, при первой итерации i равно 0, и сумма обозначает начальный столбец, при второй итерации происходит переход к следующему столбцу, а при третьей - к следующему за ним, таким образом в массиве генерируются серии элементов "01", "02", "03" 
			} else {//а если вертикальный>>
				newShipLocations.push(col + "" + (row + i));//>>то все то же самое, как и для горизонтального, только теперь вместо столбца увеличивается строка - при каждой итерации цикла к ней прибавляется i, таким образом в массиве создается серия элементов "10", "20", "30"
			}
		}
		return newShipLocations;//когда все позиции сгенерированы, метод возвращает массив
	},

	//теперь нужно избежать столкновений, применим метод collision
	collision: function (locations) {//locations - массив позиций нового корабля, который мы собираемся разместить на игровом поле
		for (var i = 0; i < this.numShips; i++) {//этот цикл перебирает все корабли модели
			var ship = model.ships[i];//для каждого корабля уже находящегося на поле>>
			for (var j = 0; j < locations.length; j++) {//>>проверить, встречается ли какая-либо из позиций массива locations нового корабля в массиве существующих(предыдущих) кораблей
				if (ship.locations.indexOf(locations[j]) >= 0) {//Метод indexOf проверяет, присутствует ли заданная позиция в массиве, таким образом, если полученный индекс больше или равен 0, мы знаем, что клетка уже занята, поэтому метод возвращает true, то есть перекрытие обнаруженно
					return true;//возврат из цикла, выполняемого в другом цикле, немедленно прерывает обы цикла, функция немедленно завершается и возвращает true
				}
			}
		}
		return false;//если выполнение дошло до этой точки, значит, ни одна из позиций не была обнаружена в других массивах, поэтому функция возвращает false то есть перекрытие отсутствует
	}
};

//реализация представления
var view = {//определяем объект и присваиваем его переменной view
	displayMessage: function(msg) {//метод displayMessage получает один аргумент - текст сообщения
		var messageArea = document.getElementById("messageArea");//получаем элемент messageArea из страницы
		messageArea.innerHTML = msg;//обновляем текст элемента messageArea, задавая его свойству innerHTML содержимое msg
	},
	displayHit: function (location) {//создаем метод displayHit, значение location образуется из строки и столбца и совпадает с идентификатором элемента <td>
		var cell = document.getElementById(location);//получаем ссылку на этот элемент методом getElementById
		cell.setAttribute("class", "hit");//с помощью метода setAttribute добавляем класс "hit" к элементу ячейки
	},
	displayMiss: function (location) {
		var cell = document.getElementById(location);
		cell.setAttribute("class", "miss");
	}
};

var controller = {//объект controller>>
	guesses: 0,//>>отслеживает кол-во выстрелов сделанных игроком

	//метод processGuess обрабатывает координаты выстрела и передает их модели, а также проверяет условие завершения игры
	processGuess: function (guess) {//метод processGuess, получает и обрабатывает координаты выстрела в формате "A0"
		var location = parseGuess(guess);//здесь метод processGuess будет использоваться для проверки введенных данных
		if (location) {//если метод не получает null, значит, был получен действительный объект location
			this.guesses++;//если игрок ввел правильные координаты, счетчик выстрелов увеличивается на 1
			var hit = model.fire(location);//комбинация строки и столбца передается методу fire
			if (hit && model.shipsSunk === model.numShips) {//если выстрел попал в цель, а кол-во потопленных кораблей равно кол-ву кораблей в игре, выводится сообщ.
				view.displayMessage("Вы потопили все мои корабли за " + this.guesses + " попыток" + ", точность " + (3/this.guesses*100) + "%");//выводим общее кол-во выстрелов, кот. потреб. игроку для того, чтобы потопить все корабли и точность попаданий в процентах
			}
		}
	}
}

//метод parseGuess получает координаты выстрела от игрока и рповеряет их на действительность
function parseGuess (guess) {//данные от игрока передаются в параметр guess
	var alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"];//массив заполняется всеми буквами, которые присутствуют в системе координат поля
	if (guess === null || guess.length !== 2) {//проверяем введенные данные на null и то что игрок ввел в строку два символа
		alert("Ой ой, пожалуйста введите буквы и цифры присутствующие на игровом поле, например A0");//если условие не выполяется, выводим сообщение о неверном вводе
	} else {
		var firstChar = guess.charAt(0);//если все good, извлекаем первый символ строки с помощью вызова charAt(позиция), представляющий строку игрового поля
		var row = alphabet.indexOf(firstChar);//при помощи метода indexOf получаем цифру от 0 до 6, соответствующую букве
		var column = guess.charAt(1);//извлекаем второй символ строки, представляющий столбец игрового поля

		if (isNaN(row) || isNaN(column)) {//функция isNaN выявляет строки и столбцы, которые не являются цифрами
			alert("Неверный код, пожалуйста введите букву, а потом цифру, например A0");//если условие не выполяется, выводим сообщение о неверном вводе
		} else if (row < 0 || row >= model.boardSize || column < 0 || column >= model.boardSize) {//проверяем что цифры лежат от 0 до 6 и запрашиваем размер доски у модели и используем его для сравнения 
			alert("Такой буквы или цифры нету на игровом поле(любые знаки - тоже ошибка)!");//если условие не выполяется, выводим сообщение о неверном вводе
		} else {
			return row + column;
		}
	}
	return null;
}

//получение координат от формы
function handleFireButton() {//создаем эту самую функцию handleFireButton, она будет вызываться при каждом нажатии кнопки Fire!
	var guessInput = document.getElementById("guessInput");//получаем ссылку на эдемент формы по идентификатору элемента "guessInput"
	var guess = guessInput.value.toUpperCase();//извлекаем данные введенные игроком, координаты хранятся в свойстве value элемента input
	controller.processGuess(guess);//координаты выстрела передаются контроллеру

	guessInput.value = "";//а это полезная команда удаляет содержимое элемента input формы, заменяя его пустой строкой
}

//обработчик нажатий клавиш
function handleKeyPress (e) {//браузер передает объект события обработчику, объект содержит информацию о том, какая клавиша была нажата
	var fireButton = document.getElementById("fireButton");//получаем ссылку на кнопку Fire! по идентификатору кнопки "fireButton"
	e = e || window.event;
	if (e.keyCode === 13) {//если нажатая клавиша есть enter(13 - это виртуальный код клавиш для JavaScript в 10-ной системе счисления)>>
		fireButton.click();//>>то кнопка Fire! должна сработать так, словно игрок щелкнул по ней мышкой(имитация нажатия кнопки)
		return false;//в противном случае возвращаем false, чтобы форма не делала ничего лишнего(например, передать данные)
	}
}

window.onload = init;//init выполняется при полной загрузке страницы

//связываем обработчик событий с кнопкой Fire!
function init () {//создаем функцию init
	var fireButton = document.getElementById("fireButton");//получаем ссылку на кнопку Fire! по идентификатору кнопки "fireButton"
	fireButton.onclick = handleFireButton;//назначаем кнопке обработчик события onclick - функцию handleFireButton
	var guessInput = document.getElementById("guessInput");//получаем ссылку на эдемент формы по идентификатору элемента "guessInput"
	guessInput.onkeypress = handleKeyPress//добавляем новый обработчик - для обработки событий нажатия клавиш в поле ввода HTML страницы

	model.generateShipLocations();//метод generateShipLocations вызывается из функции init, чтобы это происходило во время загрузки игры(до ее начала), при таком вызове позиции всех кораблей будут определены к моменту начала игры
}


